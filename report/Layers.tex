\section{Layers}

\textbf{The Dense Layer}
\newline
The Dense layer implementation is quite simple. The layer inherits the layer class and takes as arguments units and an activation function. The unit parameter sets the amount of biases and weights created, as every unit is supposed to have one of each.  The activation function is set as relu as default, since this is a good all-round activation function and commonly used.  The activation function can be altered if needed.  \\
The weights are initialized with a random normal function to ensure that the weights have different values and do not start out in a symmetrical configuration which might collapse the mapping space.  The biases are initialized with zeros to avoid adding further complexity and interfering with the weights. The layer outputs the dot-product of the input and the weights with the bias added. If an activation function is given as an argument, then this is applied to the results before it is outputted.
\newline
\newline
\textbf{The Convolutional Layer}
\newline
The convolutional layer takes as arguments filters, kernel\_size, strides, padding, activation and dilation\_rate. The filters determines how many kernels is applied in each layer and is 32 by default. This value is important for the user to tune as a hyperparameter. The kernel\_size determines the size of each kernel to run over the input and is 3 by 3 as default. The parameter strides is initialized to 1 by 1, and does the convolution operation without skipping pixels. The user can set activation function to be applied to the results after convolution and before output. The parameter padding is set to 'valid',  but the user can specify if they want another type of padding at the edges of the image.. The dilation\_rate is set to one to not do any dilution. 
\newline
\newline
\textbf{The MaxPooling Layer}
\newline
The MaxPooling layer takes as arguments the pool size, the strides, and the padding mode. The pool size defaults to $(2, 2)$ and if no strides are given, the strides are set to the pool size, resulting in non-overlapping pools. The padding mode is by default "valid", which is fine for the default case that the pool size is significantly smaller than the input. MaxPooling implements a 2-Dimensional pooling operation using the backend primitive "max\_pool2d". MaxPooling divides the 2D input data into pools of a given size and moving window distance and takes the largest value of every pool as the output. Intuitively, this can be understood as selecting the "most important" feature of a small area as a way to downsample data. MaxPooling does not have trainable weights; instead it is used for extracting features and downsampling them. The pool size acts like a tweakable meta-variable.
